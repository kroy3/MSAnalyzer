"""
plot_utils.py
--------------

Utility functions for creating publication‑quality plots for
mass‑spectrometry data.  These routines wrap Matplotlib and Seaborn
with sensible defaults and expose simple interfaces that accept
pandas DataFrames generated by the parsers.

Functions in this module do not depend on Tkinter and can be used in
headless contexts.  They return Matplotlib figure objects.  Legend
fonts are scaled down in comparison plots to avoid obscuring the data.
"""

from __future__ import annotations

from typing import List, Optional, Tuple

import pandas as pd
import matplotlib
# Use non‑interactive backend; the caller may override when embedding
matplotlib.use("Agg")  # type: ignore
import matplotlib.pyplot as plt
import seaborn as sns


def plot_channels(
    df: pd.DataFrame,
    channels: List[float],
    width: float = 8.0,
    height: float = 5.0,
    dpi: int = 300,
    title: Optional[str] = None,
) -> plt.Figure:
    """Plot selected channels from a DataFrame.

    Parameters
    ----------
    df : pandas.DataFrame
        DataFrame containing columns ``Retention Time``, ``Channel`` and
        ``Intensity``.
    channels : list of float
        The channels (m/z values) to plot.
    width, height : float
        Figure dimensions in inches.
    dpi : int
        Resolution of the figure in dots per inch.
    title : str, optional
        Title for the plot.  If None, no title is set.

    Returns
    -------
    matplotlib.figure.Figure
        The Matplotlib figure containing the plot.
    """
    sns.set(style="whitegrid")
    fig, ax = plt.subplots(figsize=(width, height), dpi=dpi)
    for ch in channels:
        sub = df[df["Channel"] == ch].copy()
        if sub.empty:
            continue
        sub.sort_values("Retention Time", inplace=True)
        label = str(int(ch)) if float(ch).is_integer() else f"{ch:.4g}"
        ax.plot(sub["Retention Time"], sub["Intensity"], label=label)
    ax.set_xlabel("Retention Time")
    ax.set_ylabel("Intensity")
    if title:
        ax.set_title(title)
    if channels:
        ax.legend(title="Channel", fontsize=8)
    fig.tight_layout()
    return fig


def compare_channels(
    df1: pd.DataFrame,
    df2: pd.DataFrame,
    channel: float,
    width: float = 8.0,
    height: float = 5.0,
    dpi: int = 300,
    labels: Optional[Tuple[str, str]] = None,
    title: Optional[str] = None,
) -> plt.Figure:
    """Plot a single channel from two DataFrames on the same axes.

    Parameters
    ----------
    df1, df2 : pandas.DataFrame
        DataFrames containing columns ``Retention Time``, ``Channel`` and
        ``Intensity``.  Typically these correspond to different functions.
    channel : float
        The channel to compare.
    width, height : float
        Figure dimensions in inches.
    dpi : int
        Resolution of the figure.
    labels : tuple of str, optional
        Labels for the two lines (defaults to ``("Function 1", "Function 2")``).
    title : str, optional
        Title of the plot.  If None, a default title is used.

    Returns
    -------
    matplotlib.figure.Figure
        A figure containing the comparison plot.
    """
    sns.set(style="whitegrid")
    fig, ax = plt.subplots(figsize=(width, height), dpi=dpi)
    lbl1, lbl2 = labels if labels is not None else ("Function A", "Function B")
    sub1 = df1[df1["Channel"] == channel].copy()
    sub2 = df2[df2["Channel"] == channel].copy()
    sub1.sort_values("Retention Time", inplace=True)
    sub2.sort_values("Retention Time", inplace=True)
    ax.plot(sub1["Retention Time"], sub1["Intensity"], label=lbl1)
    ax.plot(sub2["Retention Time"], sub2["Intensity"], label=lbl2)
    ax.set_xlabel("Retention Time")
    ax.set_ylabel("Intensity")
    chan_label = str(int(channel)) if float(channel).is_integer() else f"{channel:.4g}"
    title_text = title if title else f"Channel {chan_label} Comparison"
    ax.set_title(title_text)
    ax.legend(title="Function", fontsize=8)
    fig.tight_layout()
    return fig